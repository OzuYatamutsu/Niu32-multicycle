module Niu32_multicycle(SW,KEY,LEDR,LEDG,HEX0,HEX1,HEX2,HEX3,CLOCK_50);
    input  [9:0] SW;
    input  [3:0] KEY;
    input  CLOCK_50;
    output [9:0] LEDR;
    output [7:0] LEDG;
    output [6:0] HEX0,HEX1,HEX2,HEX3;

    parameter DBITS    =32;
    parameter INSTSIZE =32'd4;
    parameter INSTBITS =32;
    parameter REGNOBITS=5;
    parameter IMMBITS  =17;
    parameter STARTPC  =32'h60;
    parameter ADDRHEX  =32'hFFFF0000;
    parameter ADDRLEDR =32'hFFFF0020;
    parameter ADDRLEDG =32'hFFFF0040;
    
    parameter ADDRKEY  =32'hFFFF0100;
    parameter ADDRSW   =32'hFFFF0120;
    parameter IMEMINITFILE="Sorter2.mif";
    parameter IMEMADDRBITS=13;
    parameter IMEMWORDBITS=2;
    parameter IMEMWORDS=2048;
    parameter DMEMADDRBITS=13;
    parameter DMEMWORDBITS=2;
    parameter DMEMWORDS=2048;
  
    // Primary opcode values
    parameter OP1_ALUR =5'b00000;
    parameter OP1_LB   =5'b01000;
    parameter OP1_LH   =5'b01001;
    parameter OP1_LW   =5'b01010;
    parameter OP1_SB   =5'b01100;
    parameter OP1_SH   =5'b01101;
    parameter OP1_SW   =5'b01110;
    parameter OP1_BEQ  =5'b10000;
    parameter OP1_BLT  =5'b10001;
    parameter OP1_BLE  =5'b10010;
    parameter OP1_BNE  =5'b10011;
    parameter OP1_JAL  =5'b10111;
    parameter OP1_ADDI =5'b11000;
    parameter OP1_ANDI =5'b11100;
    parameter OP1_ORI  =5'b11101;
    parameter OP1_XORI =5'b11110;
  
    // Secondary opcode values
    parameter OP2_SUB  =5'b01000;
    parameter OP2_NAND =5'b01100;
    parameter OP2_NOR  =5'b01101;
    parameter OP2_NXOR =5'b01110;
    parameter OP2_EQ   =5'b10000;
    parameter OP2_LT   =5'b10001;
    parameter OP2_LE   =5'b10010;
    parameter OP2_NE   =5'b10011;
    parameter OP2_ADD  =5'b11000;
    parameter OP2_AND  =5'b11100;
    parameter OP2_OR   =5'b11101;
    parameter OP2_XOR  =5'b11110;
  
    wire clk, lock;
    Pll pll(.inclk0(CLOCK_50), .c0 (clk), .locked(lock));
    wire reset = !lock;
  
    reg [15:0] hexMem;
    reg [9:0] ledRMem;
    reg [7:0] ledGMem;

    wire [7:0] ledROut = ledRMem;
    wire [7:0] ledGOut = ledGMem;
    assign LEDR = ledROut;
    assign LEDG = ledGOut;
  
    // Create the processor's bus
    tri [(DBITS - 1):0] thebus;
    parameter BUSZ = {DBITS{1'bZ}};  

    // Create PC and connect it to the bus
    reg [(DBITS - 1):0] PC;
    reg LdPC, DrPC, IncPC;

    // PC logic: REMEMBER PC STARTS AT 0x60
    always @(posedge clk or posedge reset) begin
    if (reset)
        PC <= STARTPC;
    else if (LdPC)
        PC <= thebus;
    else if (IncPC)
        PC <= PC + INSTSIZE;
    end
  
    assign thebus = DrPC ? PC : BUSZ;
  
    // Create the instruction memory
    (* ram_init_file = IMEMINITFILE *) reg [(DBITS - 1):0] imem[(IMEMWORDS - 1):0];
    wire [(DBITS - 1):0] iMemOut = imem[PC[(IMEMADDRBITS - 1):IMEMWORDBITS]];

    // Create the IR (feeds directly from memory, not from bus)
    reg [(INSTBITS - 1):0] IR;
    reg LdIR;
  
    always @(posedge clk or posedge reset) begin
        if (reset) begin
            IR <= 32'hDEADDEAD;
        end else if (LdIR) begin
            IR <= iMemOut;
        end
    end

    // Put the code for getting opcode1, rd, rs, rt, imm, etc. here 
    wire [4:0] op1, op2;
    wire [4:0] rx, ry, rz;
    reg [4:0] ALUfunc;
    wire [16:0] imm;
    reg LdMAR, WrMem, DrMem, DrOff, ShOff;
  
    // Format of iword:
    // op1[5'bx], rx[5'bx], ry[5'bx], imm[17'bx]
    // | 31 30 29 28 27 | 26 25 24 23 22 | 
    // | 21 20 19 18 17 | 16 15 14 13 12 | 
    // | 11 10 09 08 07 06 05 | 04 03 02 01 00
    // OR:
    // op1[5'bx], rx[5'bx], ry[5'bx], 7'b0, op2[5'bx]

    assign op1 = IR[31:27];
    assign rx = IR[26:22];
    assign ry = IR[21:17];
    assign rz = IR[16:12];
    assign op2 = IR[4:0];
    assign imm = IR[16:0];

    // Put the code for data memory and I/O here
    reg [(DMEMWORDS - 1):0] mar;
    reg [(DBITS - 1):0] mdr;
    reg [(DBITS - 1):0] dmem[(IMEMWORDS - 1):0];
    wire [(DBITS - 1):0] dMemOut = mdr;
    assign thebus = DrMem ? dMemOut : BUSZ;
    reg WRHEX_FLAG, WRLEDG_FLAG, WRLEDR_FLAG, LdIO, DrIO;
    reg [(DBITS - 1):0] ioOutAddr = 32'b0;
    
    // Offset
    wire [(DBITS - 1):0] dOffOut;
    SXT(.IN(imm), .OUT(dOffOut));
    assign thebus = DrOff ? dOffOut : BUSZ;
  
    always @(posedge clk) begin
        if (WrMem && lock) begin
            dmem[mar] <= thebus;
        end else if (LdMAR && lock) begin
            mar <= thebus;
        end else if (LdIO) begin
            mar <= ioOutAddr;
        end else if (DrIO) begin
            if (ioOutAddr == ADDRHEX) begin
                hexMem <= dmem[mar];
            end else if (ioOutAddr == ADDRLEDG) begin
                ledGMem <= dmem[mar];
            end else if (ioOutAddr == ADDRLEDR) begin
                ledRMem <= dmem[mar];
            end
        end
	
        mdr <= dmem[mar[(DMEMADDRBITS - 1):DMEMWORDBITS]];
    end
   
    SevenSeg HEX0OUT(.OUT(HEX0), .IN(hexMem[3:0]));
    SevenSeg HEX1OUT(.OUT(HEX1), .IN(hexMem[7:4]));
    SevenSeg HEX2OUT(.OUT(HEX2), .IN(hexMem[11:8]));
    SevenSeg HEX3OUT(.OUT(HEX3), .IN(hexMem[15:12]));
   
    // Create the registers and connect them to the bus
    reg [(DBITS - 1):0] regs[31:0];
    reg [(REGNOBITS - 1):0] regno;
    reg WrREG, DrReg;
  
    always @(posedge clk) begin
        if (WrREG && lock) begin
            regs[regno] <= thebus;
        end
    end
  
    wire [(DBITS - 1):0] regout = WrREG ? {DBITS{1'bX}} : regs[regno];
    assign thebus = DrReg ? regout : BUSZ;

    // Create ALU unit and connect to the bus
    reg signed [(DBITS - 1):0] A, B;
    reg LdA, LdB, DrALU;
    // Connect A and B registers to the bus
    always @(posedge clk or posedge reset) begin
        if (reset) begin
            {A, B} <= 32'hDEADDEAD;
        end else begin
            if (LdA) begin
                A <= thebus;
            end if (LdB) begin
                B <= thebus;
            end
        end
    end
	
    // Connect ALU output to the bus (controlled by DrALU)
    reg signed [(DBITS - 1):0] ALUout;
    assign thebus = DrALU ? ALUout : BUSZ;
  
    // Put the code for the actual ALU here
    always @(posedge clk) begin
        case (ALUfunc)
            OP2_SUB: ALUout <= (A - B);
            OP2_NAND: ALUout <= (!(A & B));
            OP2_NOR: ALUout <= (!(A | B));
            OP2_NXOR: ALUout <= (!(A ^ B));
            OP2_EQ: ALUout <= (A == B ? 1 : 0);
            OP2_LT: ALUout <= ((A - B) < 0 ? 1 : 0);
            OP2_LE: ALUout <= ((((A - B) < 0) || (A - B) == 0) ? 1 : 0);
            OP2_NE: ALUout <= (A != B : 1 : 0);
            OP2_ADD: ALUout <= (A + B);
            OP2_AND: ALUout <= (A & B);
            OP2_OR: ALUout <= (A | B);
            OP2_XOR: ALUout <= (A ^ B);
        endcase
    end
  
    parameter S_BITS = 5;
    parameter [(S_BITS - 1):0]
    S_ZERO  = {(S_BITS) {1'b0}},					// 00h
    S_ONE   = {{(S_BITS - 1) {1'b0}}, 1'b1},        // 01h
    S_FETCH1 = S_ZERO,								// 00h
    S_FETCH2 = S_ONE,								// 01h
    S_ALUR1 = S_FETCH2 + 1'b1,					    // 02h
    S_ALUR2 = S_ALUR1 + 1'b1,						// 03h
    S_ALUR3 = S_ALUR2 + 1'b1,						// 04h
    S_LOAD1	= S_ALUR3 + 1'b1,						// 05h
    S_LOAD2	= S_LOAD1 + 1'b1,						// 06h
    S_LOAD3	= S_LOAD2 + 1'b1,						// 07h
    S_LOAD4	= S_LOAD3 + 1'b1,						// 08h
    S_STORE1 = S_LOAD4 + 1'b1,					    // 09h
    S_STORE2 = S_STORE1 + 1'b1,					    // 0ah
    S_STORE3 = S_STORE2 + 1'b1,					    // 0bh
    S_STORE4 = S_STORE3 + 1'b1,					    // 0ch
    S_BRANCH1 = S_STORE4 + 1'b1,					// 0dh
    S_BRANCH2 = S_BRANCH1 + 1'b1,				    // 0eh
    S_BRANCH3 = S_BRANCH2 + 1'b1,				    // 0fh
    S_BRANCH4 = S_BRANCH3 + 1'b1,				    // 10h
    S_BRANCH5 = S_BRANCH4 + 1'b1,				    // 11h
    S_BRANCH6 = S_BRANCH5 + 1'b1,				    // 12h
    S_BRANCH7 = S_BRANCH6 + 1'b1,				    // 13h
    S_JUMP1 = S_BRANCH7 + 1'b1,					    // 14h 
    S_JUMP2 = S_JUMP1 + 1'b1,						// 15h
    S_JUMP3 = S_JUMP2 + 1'b1,						// 16h
    S_JUMP4 = S_JUMP3 + 1'b1,						// 17h
    S_JUMP5 = S_JUMP4 + 1'b1,						// 18h
    S_JUMP6 = S_JUMP5 + 1'b1,						// 19h
    S_ALUI1 = S_JUMP6 + 1'b1,						// 1ah
    S_ALUI2 = S_ALUI1 + 1'b1,						// 1bh
    S_ALUI3 = S_ALUI2 + 1'b1,						// 1ch
    S_OUTPUT1 = S_ALUI3 + 1'b1,                     // 1dh
    S_OUTPUT2 = S_OUTPUT1 + 1'b1,                   // 1eh
    S_ERROR = 5'b11111;								// 1fh
	 
    reg [(S_BITS - 1):0] state, next_state;
    always @(state or op1 or rx or ry or rz or op2 or ALUout[0]) begin
        {LdPC, DrPC, IncPC, LdMAR, WrMem, DrMem, LdIR, DrOff, ShOff, LdA, LdB, ALUfunc, DrALU, regno, DrReg, WrREG, next_state}=
        {1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 5'bX, 1'b0, 5'b0, 1'b0, 1'b0, state + S_ONE};
        {ioOutAddr, LdIO, DrIO, WRHEX_FLAG, WRLEDG_FLAG, WRLEDR_FLAG} = {32'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0};
	 
        case (state)
            S_FETCH1: begin  
               {LdIR, IncPC} = {1'b1, 1'b1};
                next_state = S_FETCH2;
            end 
	 
            S_FETCH2: begin
                case (op1)
                    OP1_ALUR: begin
                        case (op2)
                            OP2_SUB,
                            OP2_NAND, OP2_NOR, OP2_NXOR,
                            OP2_EQ, OP2_LT, OP2_LE, OP2_NE,
                            OP2_ADD,
                            OP2_AND, OP2_OR, OP2_XOR:
                                next_state = S_ALUR1;
                        default: next_state = S_ERROR;
                        endcase
                    end
                    
                    OP1_LB, OP1_LH, OP1_LW:
                        next_state = S_LOAD1;
                    
                    OP1_SB, OP1_SH, OP1_SW:
                        next_state = S_STORE1;
                    
                    OP1_BEQ, OP1_BLT, OP1_BLE, OP1_BNE: begin
                        next_state = S_BRANCH1;
                    end
                    
                    OP1_JAL:
                        next_state = S_JUMP1;
                    
                    OP1_ADDI, OP1_ANDI, OP1_ORI, OP1_XORI:
                        next_state = S_ALUI1;
                    
                    default: next_state = S_ERROR;
                endcase
            end
		
            S_ALUR1: begin
                {regno, DrReg, LdA} = {rx, 1'b1, 1'b1};
                next_state = S_ALUR2;
            end
	
            S_ALUR2: begin
                {regno, DrReg, LdB} = {ry, 1'b1, 1'b1};
                next_state = S_ALUR3;
            end
            
            S_ALUR3: begin
                {regno, ALUfunc, DrALU, WrREG} = {rz, op2, 1'b1, 1'b1};
                next_state = S_FETCH1;
            end
            
            S_LOAD1: begin
                {regno, DrReg, LdA} = {rx, 1'b1, 1'b1};
                next_state = S_LOAD2;
            end

            S_LOAD2: begin
                {DrOff, LdB} = {1'b1, 1'b1};
                next_state = S_LOAD3;
            end
            
            S_LOAD3: begin
                {ALUfunc, DrALU, LdMAR} = {OP2_ADD, 1'b1, 1'b1};
                next_state = S_LOAD4;
            end
	
            S_LOAD4: begin
                {regno, WrREG, DrMem} = {ry, 1'b1, 1'b1};
                next_state = S_FETCH1;
            end
	
            S_STORE1: begin
                {regno, DrReg, LdA} = {rx, 1'b1, 1'b1};
                
                next_state = S_STORE2;
            end
	
            S_STORE2: begin
                {DrOff, LdB} = {1'b1, 1'b1};
                
                next_state = S_STORE3;
            end
	
            S_STORE3: begin
                {ALUfunc, DrALU, LdMAR} = {OP2_ADD, 1'b1, 1'b1};
                
                next_state = S_STORE4;
            end
	
            S_STORE4: begin
                {regno, DrReg, WrMem} = {ry, 1'b1, 1'b1};
                
                if (ALUout == ADDRHEX) begin
                    WRHEX_FLAG = 1'b1;
                end else if (ALUout == ADDRLEDG) begin
                    WRLEDG_FLAG = 1'b1;
                end else if (ALUout == ADDRLEDR) begin
                    WRLEDR_FLAG = 1'b1;
                end
               
                if (WRLEDG_FLAG || WRLEDR_FLAG || WRHEX_FLAG) begin
                    next_state = S_OUTPUT1;
                end else begin
                    next_state = S_FETCH1;
                end
            end
	
            S_BRANCH1: begin
                {regno, DrReg, LdA} = {rx, 1'b1, 1'b1};
                next_state = S_BRANCH2;
            end
            
            S_BRANCH2: begin
                {regno, DrReg, LdB} = {ry, 1'b1, 1'b1};
                next_state = S_BRANCH3;
            end
	
            S_BRANCH3: begin
                case (op1)
                    OP1_BEQ: ALUfunc = OP2_EQ;
                    OP1_BLT: ALUfunc = OP2_LT;
                    OP1_BLE: ALUfunc = OP2_LE;
                    OP1_BNE: ALUfunc = OP2_NE;
                    default: ALUfunc = OP2_EQ;
                endcase
                
                if (ALUout == 1) begin
                    next_state = S_BRANCH4;
                end else begin
                    next_state = S_FETCH1;
                end
            end

            S_BRANCH4: begin
                IncPC = 1'b1;
                next_state = S_BRANCH5;
            end
            
            S_BRANCH5: begin
                {DrPC, LdA} = {1'b1, 1'b1};
                next_state = S_BRANCH6;
            end
	
            S_BRANCH6: begin
                {DrOff, LdB} = {1'b1, 1'b1};
                // TODO: ShOff, maybe? We need 4*imm
                next_state = S_BRANCH7;
            end
            
            S_BRANCH7: begin
                // What about saving old PC value...?
                {ALUfunc, DrALU, LdPC} = {OP2_ADD, 1'b1, 1'b1};
                next_state = S_FETCH1;
            end
                
            S_JUMP1: begin
                IncPC = 1'b1;
                next_state = S_JUMP2;
            end
            
            S_JUMP2: begin
                {DrPC, LdA} = {1'b1, 1'b1};
                next_state = S_JUMP3;
            end
	
            S_JUMP3: begin
                {regno, DrALU, WrREG} = {ry, 1'b1, 1'b1};
                next_state = S_JUMP4;
            end
            
            S_JUMP4: begin
                {regno, DrReg, LdA} = {rx, 1'b1, 1'b1};
                next_state = S_JUMP5;
            end
            
            S_JUMP5: begin
                {DrOff, LdB} = {1'b1, 1'b1};
                // TODO: ShOff, maybe? We need 4*imm
                next_state = S_JUMP6;
            end
	
            S_JUMP6: begin
                {ALUfunc, DrALU, LdPC} = {OP2_ADD, 1'b1, 1'b1};
                next_state = S_FETCH1;
            end
            
            S_ALUI1: begin
                {regno, DrReg, LdA} = {rx, 1'b1, 1'b1};
                
                next_state = S_ALUI2;
            end
	
            S_ALUI2: begin
                {DrOff, LdB} = {1'b1, 1'b1};
                next_state = S_ALUI3;
            end
            
            S_ALUI3: begin
                {regno, DrALU, WrREG} = {ry, 1'b1, 1'b1};
            
                case (op1)
                    OP1_ADDI: ALUfunc = OP2_ADD;
                    OP1_ANDI: ALUfunc = OP2_AND;
                    OP1_ORI: ALUfunc = OP2_OR;
                    OP1_XORI: ALUfunc = OP2_XOR;
                    default: ALUfunc = OP2_SUB;
                endcase
                
                next_state = S_FETCH1;
            end
            
            S_OUTPUT1: begin
                if (WRLEDG_FLAG) begin
                    ioOutAddr <= ADDRLEDG;
                end if (WRLEDR_FLAG) begin
                    ioOutAddr <= ADDRLEDR;
                end if (WRHEX_FLAG) begin
                    ioOutAddr <= ADDRHEX;
                end
                
                LdIO = 1; // BLOCKING!
                next_state = S_OUTPUT2;
            end
            
            S_OUTPUT2: begin
                DrIO = 1; // BLOCKING!
                next_state = S_FETCH1;
            end
	
            default:  next_state = S_ERROR;
        endcase
    end
  
   always @(posedge clk or posedge reset) begin
      if (reset) begin
         state <= S_FETCH1;
      end else begin
         state <= next_state;
      end
   end
endmodule

module SXT(IN, OUT);
   parameter IBITS = 17;
   parameter OBITS = 32;
   input  [(IBITS - 1):0] IN;
   output [(OBITS - 1):0] OUT;
   assign OUT={{(OBITS - IBITS) {IN[IBITS - 1]}}, IN};
endmodule
